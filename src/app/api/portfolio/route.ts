import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { getGitHubProfile } from "@/lib/github";
import jsPDF from "jspdf";

export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);
    const { username, resumeText, statement } = await req.json();

    if (!username) {
      return NextResponse.json({ error: "Username is required" }, { status: 400 });
    }

    // @ts-expect-error extending session type
    const token = session?.accessToken;
    const profile = await getGitHubProfile(username, token);

    // Create PDF
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = 20;
    let yPosition = margin;

    // Helper function to add text with word wrapping
    const addText = (text: string, fontSize: number, isBold = false, color: [number, number, number] = [0, 0, 0]) => {
      doc.setFontSize(fontSize);
      doc.setTextColor(color[0], color[1], color[2]);
      if (isBold) {
        doc.setFont("helvetica", "bold");
      } else {
        doc.setFont("helvetica", "normal");
      }
      
      const lines = doc.splitTextToSize(text, pageWidth - 2 * margin);
      const lineHeight = fontSize * 0.5;
      
      lines.forEach((line: string) => {
        if (yPosition + lineHeight > pageHeight - margin) {
          doc.addPage();
          yPosition = margin;
        }
        doc.text(line, margin, yPosition);
        yPosition += lineHeight;
      });
      yPosition += 5;
    };

    const addSection = (title: string) => {
      yPosition += 5;
      doc.setDrawColor(255, 107, 53); // Basely orange
      doc.setLineWidth(0.5);
      doc.line(margin, yPosition, pageWidth - margin, yPosition);
      yPosition += 8;
      addText(title, 16, true, [255, 107, 53]);
    };

    // Header
    doc.setFillColor(255, 107, 53);
    doc.rect(0, 0, pageWidth, 40, "F");
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(24);
    doc.setFont("helvetica", "bold");
    doc.text("TECHNICAL PORTFOLIO", pageWidth / 2, 15, { align: "center" });
    doc.setFontSize(12);
    doc.text("Generated by Basely.Connect", pageWidth / 2, 25, { align: "center" });
    
    yPosition = 50;

    // Personal Information
    addSection("PERSONAL INFORMATION");
    addText(`Name: ${profile.name || username}`, 12, true);
    if (profile.bio) addText(`Bio: ${profile.bio}`, 10);
    if (profile.location) addText(`Location: ${profile.location}`, 10);
    if (profile.company) addText(`Company: ${profile.company}`, 10);
    if (profile.blog) addText(`Website: ${profile.blog}`, 10);
    addText(`GitHub: https://github.com/${username}`, 10);

    // Personal Statement
    if (statement) {
      addSection("PROFESSIONAL STATEMENT");
      addText(statement, 10);
    }

    // GitHub Profile Summary
    addSection("GITHUB PROFILE SUMMARY");
    addText(`Total Repositories: ${profile.totalRepos}`, 10);
    addText(`Total Stars: ${profile.totalStars}`, 10);
    addText(`Total Code Size: ${Math.round(profile.totalSize / 1024)} KB`, 10);

    // Top Languages
    if (profile.topLanguages && profile.topLanguages.length > 0) {
      addSection("TOP PROGRAMMING LANGUAGES");
      addText(profile.topLanguages.join(", "), 10);
    }

    // Organizations
    if (profile.organizations && profile.organizations.length > 0) {
      addSection("ORGANIZATIONS");
      profile.organizations.forEach((org: { login: string; description?: string }) => {
        addText(`• ${org.login}${org.description ? `: ${org.description}` : ''}`, 10);
      });
    }

    // Social Accounts
    if (profile.socialAccounts && profile.socialAccounts.length > 0) {
      addSection("SOCIAL PROFILES");
      profile.socialAccounts.forEach((social: { provider: string; url: string }) => {
        addText(`• ${social.provider}: ${social.url}`, 10);
      });
    }

    // Top Repositories
    if (profile.repos && profile.repos.length > 0) {
      addSection("NOTABLE REPOSITORIES");
      profile.repos.slice(0, 10).forEach((repo: { 
        name: string; 
        description: string; 
        language: string; 
        stars: number;
        topics?: string[];
      }) => {
        addText(`${repo.name} ★${repo.stars}`, 11, true);
        if (repo.description) {
          addText(repo.description, 9);
        }
        addText(`Language: ${repo.language || 'N/A'}`, 9, false, [100, 100, 100]);
        if (repo.topics && repo.topics.length > 0) {
          addText(`Topics: ${repo.topics.join(', ')}`, 9, false, [100, 100, 100]);
        }
        yPosition += 3;
      });
    }

    // Profile README
    if (profile.profileReadme) {
      addSection("PROFILE README");
      // Truncate if too long
      const readmeText = profile.profileReadme.length > 2000 
        ? profile.profileReadme.substring(0, 2000) + "..."
        : profile.profileReadme;
      addText(readmeText, 9);
    }

    // Resume Content
    if (resumeText) {
      addSection("RESUME");
      // Truncate if too long
      const resumeContent = resumeText.length > 3000
        ? resumeText.substring(0, 3000) + "..."
        : resumeText;
      addText(resumeContent, 9);
    }

    // Footer
    doc.setFontSize(8);
    doc.setTextColor(150, 150, 150);
    const totalPages = doc.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      doc.setPage(i);
      doc.text(
        `Generated on ${new Date().toLocaleDateString()} | Page ${i} of ${totalPages}`,
        pageWidth / 2,
        pageHeight - 10,
        { align: "center" }
      );
    }

    // Generate PDF as buffer
    const pdfBuffer = doc.output("arraybuffer");

    // Return PDF
    return new NextResponse(pdfBuffer, {
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="${username}-portfolio.pdf"`,
      },
    });

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error("Portfolio generation error:", error);
    return NextResponse.json(
      { error: error.message || "Failed to generate portfolio" },
      { status: 500 }
    );
  }
}
